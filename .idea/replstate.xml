<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1471015312604">{:repl-history {:ide [], :local [&quot;(in-ns 'sockjs.core)&quot; &quot;-&gt;&quot; &quot;(ns sockjs.session\n  (:require [immutant.web             :as web]\n            [immutant.web.async       :as async]\n            [immutant.web.middleware  :as web-middleware]\n            [immutant.scheduling :refer :all]\n            [cheshire.core :as json]\n            [clojure.string :as cstr]))&quot; &quot;(defprotocol SockjsConnection\n  (on-open [this session])\n  (on-message [this session msg])\n  (on-close [this session]))&quot; &quot;(defn escape-json [s]\n  (cstr/replace\n   s\n   (java.util.regex.Pattern/compile\n    \&quot;[\\\\x00-\\\\x1f\\\\ud800-\\\\udfff\\\\u200c-\\\\u200f\\\\u2028-\\\\u202f\\\\u2060-\\\\u206f\\\\ufff0-\\\\uffff]\&quot;)\n   (fn [match]\n     (let [e (str \&quot;0000\&quot; (Integer/toHexString (int (.charAt match 0))))]\n       (str \&quot;\\\\u\&quot; (.substring e (- (.length e) 4)))))))&quot; &quot;(defn to-json [str]\n  (escape-json (json/generate-string str)))&quot; &quot;(defn format-message [msg]\n  (condp = (:type msg)\n    :open \&quot;o\&quot;\n    :close (str \&quot;c[\&quot; (:close-number msg) \&quot;,\\\&quot;\&quot; (:close-reason msg) \&quot;\\\&quot;]\&quot;)\n    :heatbeat \&quot;h\&quot;\n    (str \&quot;a[\&quot; (if (map? msg)\n                (cond\n                 (sequential? (:content msg))\n                 ,(cstr/join \&quot;,\&quot; (map to-json (:content msg)))\n                 :else (to-json (:content msg)))\n                (to-json msg))\n              \&quot;]\&quot;)))&quot; &quot;(defprotocol PSession\n  (send! [this msg])\n  (close! [this nb reason])\n  (unregister-channel [this])\n  (register-channel [this channel]))&quot; &quot;(defn in-response-limit? [session]\n  (let [limit (:response-limit session)\n        current @(:bytes-send session)]\n    (if (nil? limit)\n      true\n      (&lt; current limit))))&quot; &quot;(declare open-channel?)&quot; &quot;(declare remove-session!)&quot; &quot;(defn start-heatbeat [session]\n  (let [timer-ref (:heatbeat-timer session)]\n    (when (not (nil? @timer-ref))\n      (timer/cancel @timer-ref))\n    (reset! timer-ref (timer/schedule-task\n                       (or (:heatbeat-delay session) 25000)\n                       (when (open-channel? session)\n                         (send! session {:type :heatbeat})\n                         (start-heatbeat session))))))&quot; &quot;(defn start-heatbeat [session]\n  (let [timer-ref (:heatbeat-timer session)]\n    (when (not (nil? @timer-ref))\n      (stop @timer-ref))\n    (reset! timer-ref (schedule\n                       (or (:heatbeat-delay session) 25000)\n                       (when (open-channel? session)\n                         (send! session {:type :heatbeat})\n                         (start-heatbeat session))))))&quot; &quot;(defn stop-heatbeat [session]\n  (let [timer-ref (:heatbeat-timer session)]\n    (when (not (nil? @timer-ref))\n      (timer/cancel @timer-ref))))&quot; &quot;(defn stop-heatbeat [session]\n  (let [timer-ref (:heatbeat-timer session)]\n    (when (not (nil? @timer-ref))\n      (stop @timer-ref))))&quot; &quot;(defn start-disconnect [session]\n  (let [timer-ref (:disconnect-timer session)]\n    (when (not (nil? @timer-ref))\n      (stop @timer-ref))\n    (reset! timer-ref (timer/schedule-task\n                       (or (:disconnect-delay session) 5000)\n                       (when-not (open-channel? session)\n                         (stop-heatbeat session)\n                         (remove-session! session))))\n    session))&quot; &quot;(defn start-disconnect [session]\n  (let [timer-ref (:disconnect-timer session)]\n    (when (not (nil? @timer-ref))\n      (stop @timer-ref))\n    (reset! timer-ref (schedule\n                       (or (:disconnect-delay session) 5000)\n                       (when-not (open-channel? session)\n                         (stop-heatbeat session)\n                         (remove-session! session))))\n    session))&quot; &quot;(defn stop-heatbeat [session]\n  (let [timer-ref (:disconnect-timer session)]\n    (when (not (nil? @timer-ref))\n      (timer/cancel @timer-ref))))&quot; &quot;(defn stop-heatbeat [session]\n  (let [timer-ref (:disconnect-timer session)]\n    (when (not (nil? @timer-ref))\n      (stop @timer-ref))))&quot; &quot;(defrecord StreamingSession [channel buffer fmt bytes-send disconnect-timer\n                             heatbeat-timer]\n  PSession\n  \n  (send! [this msg]\n    (if (and (not (nil? @channel))\n             (server/open? @channel)\n             (in-response-limit? this))\n      (let [msg (-&gt; msg format-message fmt)]\n        (server/send! @channel msg false)\n        (swap! bytes-send + (count msg))\n        (when-not (in-response-limit? this)\n          (server/close @channel)))\n      (swap! buffer conj msg))\n    this)\n  \n  (close! [this nb reason]\n    (when (server/open? @channel)\n      (send! this {:type :close\n                   :close-number nb\n                   :close-reason reason})\n      (server/close @channel))\n    (on-close\n     (:sockjs-handler this)\n     (-&gt; this\n         (assoc :ready-state :closed)\n         (assoc :close-number nb)\n         (assoc :close-reason reason))))\n\n  (unregister-channel [this]\n    (stop-heatbeat this)\n    (reset! channel nil)\n    this)\n\n  (register-channel [this ch]\n    (reset! channel ch)\n    (start-heatbeat this)\n    (doseq [m @buffer\n            :let [msg (-&gt; m format-message fmt)]]\n      (server/send! ch msg false)\n      (swap! buffer rest))\n    this))&quot; &quot;(defrecord StreamingSession [channel buffer fmt bytes-send disconnect-timer\n                             heatbeat-timer]\n  PSession\n  \n  (send! [this msg]\n    (if (and (not (nil? @channel))\n             (async/open? @channel)\n             (in-response-limit? this))\n      (let [msg (-&gt; msg format-message fmt)]\n        (async/send! @channel msg false)\n        (swap! bytes-send + (count msg))\n        (when-not (in-response-limit? this)\n          (async/close @channel)))\n      (swap! buffer conj msg))\n    this)\n  \n  (close! [this nb reason]\n    (when (async/open? @channel)\n      (send! this {:type :close\n                   :close-number nb\n                   :close-reason reason})\n      (async/close @channel))\n    (on-close\n     (:sockjs-handler this)\n     (-&gt; this\n         (assoc :ready-state :closed)\n         (assoc :close-number nb)\n         (assoc :close-reason reason))))\n\n  (unregister-channel [this]\n    (stop-heatbeat this)\n    (reset! channel nil)\n    this)\n\n  (register-channel [this ch]\n    (reset! channel ch)\n    (start-heatbeat this)\n    (doseq [m @buffer\n            :let [msg (-&gt; m format-message fmt)]]\n      (async/send! ch msg false)\n      (swap! buffer rest))\n    this))&quot; &quot;(defrecord PollingSession [channel buffer fmt disconnect-timer]\n  PSession\n\n  (send! [this msg]\n    (swap! buffer conj msg)\n    this)\n\n  (close! [this nb reason]\n    (on-close\n     (:sockjs-handler this)\n     (-&gt; this\n         (assoc :ready-state :closed)\n         (assoc :close-number nb)\n         (assoc :close-reason reason))))\n\n  (unregister-channel [this]\n    (reset! channel nil)\n    this)\n  \n  (register-channel [this ch]\n    (reset! channel ch) ;; only store to detect duplicate connections\n    (if-not (empty? @buffer)\n      (let [msgs @buffer\n            open-msg (filter #(= (:type %) :open) msgs)\n            close-msg (filter #(= (:type %) :close) msgs)\n            content-msg (filter #(= (:type %) :msg) msgs)\n            content-msg (if (empty? content-msg)\n                          content-msg\n                          [{:type :msg\n                            :content (map :content content-msg)}])\n            msgs (concat open-msg content-msg close-msg)]\n        (reset! buffer [])\n        (server/send! ch (apply str (map (comp fmt format-message) msgs)))\n        (server/close ch)\n        this)\n      this)))&quot; &quot;(defrecord PollingSession [channel buffer fmt disconnect-timer]\n  PSession\n\n  (send! [this msg]\n    (swap! buffer conj msg)\n    this)\n\n  (close! [this nb reason]\n    (on-close\n     (:sockjs-handler this)\n     (-&gt; this\n         (assoc :ready-state :closed)\n         (assoc :close-number nb)\n         (assoc :close-reason reason))))\n\n  (unregister-channel [this]\n    (reset! channel nil)\n    this)\n  \n  (register-channel [this ch]\n    (reset! channel ch) ;; only store to detect duplicate connections\n    (if-not (empty? @buffer)\n      (let [msgs @buffer\n            open-msg (filter #(= (:type %) :open) msgs)\n            close-msg (filter #(= (:type %) :close) msgs)\n            content-msg (filter #(= (:type %) :msg) msgs)\n            content-msg (if (empty? content-msg)\n                          content-msg\n                          [{:type :msg\n                            :content (map :content content-msg)}])\n            msgs (concat open-msg content-msg close-msg)]\n        (reset! buffer [])\n        (async/send! ch (apply str (map (comp fmt format-message) msgs)))\n        (async/close ch)\n        this)\n      this)))&quot; &quot;(def initial-data\n  {:ready-state :connecting})&quot; &quot;(defn create-streaming-session [id fmt &amp; kvs]\n  (-&gt; (-&gt;StreamingSession (atom nil) (atom []) fmt (atom 0)\n                          (atom nil) (atom nil))\n      (merge initial-data (apply hash-map kvs))\n      (assoc :id id)))&quot; &quot;(defn create-polling-session [id fmt &amp; kvs]\n  (-&gt; (-&gt;PollingSession (atom nil) (atom []) fmt\n                        (atom nil))\n      (merge initial-data (apply hash-map kvs))\n      (assoc :id id)))&quot; &quot;(defn assoc-ready-state [session state]\n  (assoc session :ready-state state))&quot; &quot;(defn close [session nb reason]\n  (-&gt; session\n      (assoc-ready-state :closed)\n      (assoc :close-number nb)\n      (assoc :close-reason reason)))&quot; &quot;(defn closed? [session]\n  (= (:ready-state session) :closed))&quot; &quot;(defn open-channel? [session]\n  (let [channel @(:channel session)]\n    (and (not (nil? channel))\n         (server/open? channel))))&quot; &quot;(defn open-channel? [session]\n  (let [channel @(:channel session)]\n    (and (not (nil? channel))\n         (async/open? channel))))&quot; &quot;(def sessions (atom {}))&quot; &quot;(ns sockjs.action\n  (:require [cheshire.core :as json]\n            [clojure.string :as cstr]\n            [sockjs.filter :as f]\n            [immutant.web             :as web]\n            [immutant.web.async       :as async]\n            [sockjs.session :as session]))&quot; &quot;(defn error-500 [msg]\n  {:status 500\n   :headers {\&quot;Content-Type\&quot; \&quot;text/plain; charset=UTF-8\&quot;}\n   :body msg})&quot; &quot;(def response-404\n  {:status 404\n   :headers {\&quot;Content-Type\&quot; \&quot;text/plain; charset=UTF-8\&quot;}\n   :body \&quot;\&quot;})&quot; &quot;(defn initialize-session\n  \&quot;initializes a new session\&quot;\n  [s channel sockjs-handler]\n  ;; register to storage\n  (session/register-session s)\n  ;; register channel\n  (session/register-new-channel! (:id s) channel)\n  ;; call on open handler\n  (session/update-session! (:id s) #(session/on-open sockjs-handler %)))&quot; &quot;(defn websocket-on-receive\n  \&quot;returns the websocket on-receive function for a given session and channel\&quot;\n  [session-id sockjs-handler channel]\n  (fn [msg]\n    (when-not (empty? msg) ;; only handle non-empty messages\n      (try\n        (let [msgs (json/parse-string msg)]\n          (doseq [m msgs]\n            (session/update-session!\n             session-id\n             #(session/on-message sockjs-handler % m))))\n        (catch com.fasterxml.jackson.core.JsonParseException e\n          ;; close channel when invalid json is send.\n          (server/close channel))))))&quot; &quot;(defn websocket-on-receive\n  \&quot;returns the websocket on-receive function for a given session and channel\&quot;\n  [session-id sockjs-handler channel]\n  (fn [msg]\n    (when-not (empty? msg) ;; only handle non-empty messages\n      (try\n        (let [msgs (json/parse-string msg)]\n          (doseq [m msgs]\n            (session/update-session!\n             session-id\n             #(session/on-message sockjs-handler % m))))\n        (catch com.fasterxml.jackson.core.JsonParseException e\n          ;; close channel when invalid json is send.\n          (async/close channel))))))&quot; &quot;(defn websocket-on-close\n  \&quot;returns the websocket on-close function for a given session id\&quot;\n  [session-id]\n  (fn [status]\n    ;; when the connection is closed, close also the session\n    (session/update-session! session-id #(session/close! % 3000 status))))&quot; &quot;(defn websocket\n  \&quot;the websocket request handler\&quot;\n  [req session-id {:keys [sockjs-handler heatbeat-delay disconnect-delay]}]\n  (println (:headers req))\n  (if-not (:websocket? req)\n    ;; if no websocket request return a message to upgrade to websocket\n    {:status 400\n     :body \&quot;Can \\\&quot;Upgrade\\\&quot; only to \\\&quot;WebSocket\\\&quot;.\&quot;}\n    ;; if we have a websocket connection initial the channel\n    (async/with-channel req channel\n      (if-not (session/session? session-id)\n        (let [s (session/create-streaming-session\n                 session-id identity\n                 :sockjs-handler sockjs-handler\n                 :heatbeat-delay heatbeat-delay\n                 :disconnect-delay disconnect-delay)]\n          (initialize-session s channel sockjs-handler))\n        (session/register-new-channel! session-id channel))\n      (async/on-receive\n       channel\n       (websocket-on-receive session-id sockjs-handler channel))\n      (async/on-close\n       channel\n       (websocket-on-close session-id)))))&quot; &quot;(defn websocket\n  \&quot;the websocket request handler\&quot;\n  [req session-id {:keys [sockjs-handler heatbeat-delay disconnect-delay]}]\n  (println (:headers req))\n  (if-not (:websocket? req)\n    ;; if no websocket request return a message to upgrade to websocket\n    {:status 400\n     :body \&quot;Can \\\&quot;Upgrade\\\&quot; only to \\\&quot;WebSocket\\\&quot;.\&quot;}\n    ;; if we have a websocket connection initial the channel\n    (async/as-channel req channel\n      (if-not (session/session? session-id)\n        (let [s (session/create-streaming-session\n                 session-id identity\n                 :sockjs-handler sockjs-handler\n                 :heatbeat-delay heatbeat-delay\n                 :disconnect-delay disconnect-delay)]\n          (initialize-session s channel sockjs-handler))\n        (session/register-new-channel! session-id channel))\n      (async/on-receive\n       channel\n       (websocket-on-receive session-id sockjs-handler channel))\n      (async/on-close\n       channel\n       (websocket-on-close session-id)))))&quot; &quot;(defn websocket\n  \&quot;the websocket request handler\&quot;\n  [req session-id {:keys [sockjs-handler heatbeat-delay disconnect-delay]}]\n  (println (:headers req))\n  (if-not (:websocket? req)\n    ;; if no websocket request return a message to upgrade to websocket\n    {:status 400\n     :body \&quot;Can \\\&quot;Upgrade\\\&quot; only to \\\&quot;WebSocket\\\&quot;.\&quot;}\n    ;; if we have a websocket connection initial the channel\n    (async/as-channel req\n                      {:on-open (fn [channel]\n                                  (if-not (session/session? session-id)\n                                    (let [s (session/create-streaming-session\n                                              session-id identity\n                                              :sockjs-handler sockjs-handler\n                                              :heatbeat-delay heatbeat-delay\n                                              :disconnect-delay disconnect-delay)]\n                                      (initialize-session s stream sockjs-handler))\n                                    (session/register-new-channel! session-id channel)))}\n                      {:on-message (fn [channel]\n                                     (websocket-on-receive session-id sockjs-handler channel))}\n                      {:on-close (fn [channel]\n                                   (websocket-on-close session-id))})))&quot; &quot;(defn websocket\n  \&quot;the websocket request handler\&quot;\n  [req session-id {:keys [sockjs-handler heatbeat-delay disconnect-delay]}]\n  (println (:headers req))\n  (if-not (:websocket? req)\n    ;; if no websocket request return a message to upgrade to websocket\n    {:status 400\n     :body \&quot;Can \\\&quot;Upgrade\\\&quot; only to \\\&quot;WebSocket\\\&quot;.\&quot;}\n    ;; if we have a websocket connection initial the channel\n    (async/as-channel req\n                      {:on-open (fn [channel]\n                                  (if-not (session/session? session-id)\n                                    (let [s (session/create-streaming-session\n                                              session-id identity\n                                              :sockjs-handler sockjs-handler\n                                              :heatbeat-delay heatbeat-delay\n                                              :disconnect-delay disconnect-delay)]\n                                      (initialize-session s channel sockjs-handler))\n                                    (session/register-new-channel! session-id channel)))}\n                      {:on-message (fn [channel]\n                                     (websocket-on-receive session-id sockjs-handler channel))}\n                      {:on-close (fn [channel]\n                                   (websocket-on-close session-id))})))&quot; &quot;(defn xhr-streaming\n  \&quot;the xhr streaming request handler.\&quot;\n  [req session-id {:keys [sockjs-handler heatbeat-delay disconnect-delay\n                          response-limit] :as opts}]\n  (async/with-channel req channel\n    (async/on-close channel\n                     (fn [status]\n                       (session/update-session! session-id #(session/close! % 1002 \&quot;Connection interrupted\&quot;))))\n\n\n    ;; always send 2049 bytes preclude\n    (async/send! channel\n                  (-&gt;&gt; {:status 200\n                        :headers {\&quot;Content-Type\&quot;\n                                  \&quot;application/javascript; charset=UTF-8\&quot;}\n                        :body (str (apply str (repeat 2048 \&quot;h\&quot;)) \&quot;\\n\&quot;)}\n                       (f/h-sid req opts)\n                       (f/h-no-cache req opts)\n                       (f/xhr-cors req opts)\n                       (f/status-200 req opts))\n                  false)\n    ;; register the new channel\n    (if-not (session/session? session-id)\n      (let [s (session/create-streaming-session\n               session-id (fn [m] (str m \&quot;\\n\&quot;))\n               :response-limit response-limit\n               :heatbeat-delay heatbeat-delay\n               :disconnect-delay disconnect-delay\n               :sockjs-handler sockjs-handler)]\n        (initialize-session s channel sockjs-handler))\n      (session/register-new-channel! session-id channel))))&quot; &quot;(defn xhr-streaming\n  \&quot;the xhr streaming request handler.\&quot;\n  [req session-id {:keys [sockjs-handler heatbeat-delay disconnect-delay\n                          response-limit] :as opts}]\n  (async/as-channel req\n    {:on-close (fn [channel\n                    (session/update-session! session-id #(session/close! % 1002 \&quot;Connection interrupted\&quot;))])}\n    {:on-open (fn [channel\n                    (async/send! channel \n                       (-&gt;&gt; {:status 200}\n                          :headers {\&quot;Content-Type\&quot;\n                                    \&quot;application/javascript; charset=UTF-8\&quot;}\n                          :body (str (apply str (repeat 2048 \&quot;h\&quot;)) \&quot;\\n\&quot;)\n                         (f/h-sid req opts)\n                         (f/h-no-cache req opts)\n                         (f/xhr-cors req opts)\n                         (f/status-200 req opts))\n                       false)\n                   ;; register the new channel\n                   (if-not (session/session? session-id)\n                     (let [s (session/create-streaming-session\n                               session-id (fn [m] (str m \&quot;\\n\&quot;))\n                               :response-limit response-limit\n                               :heatbeat-delay heatbeat-delay\n                               :disconnect-delay disconnect-delay\n                               :sockjs-handler sockjs-handler)]\n                       (initialize-session s channel sockjs-handler))\n                     (session/register-new-channel! session-id channel))])}))&quot; &quot;(defn xhr-streaming\n  \&quot;the xhr streaming request handler.\&quot;\n  [req session-id {:keys [sockjs-handler heatbeat-delay disconnect-delay\n                          response-limit] :as opts}]\n  (async/as-channel req\n    {:on-close (fn [channel] \n                   (session/update-session! session-id #(session/close! % 1002 \&quot;Connection interrupted\&quot;)))}\n    {:on-open (fn [channel]\n                  (async/send! channel \n                     (-&gt;&gt; {:status 200}\n                        :headers {\&quot;Content-Type\&quot;\n                                  \&quot;application/javascript; charset=UTF-8\&quot;}\n                        :body (str (apply str (repeat 2048 \&quot;h\&quot;)) \&quot;\\n\&quot;)\n                       (f/h-sid req opts)\n                       (f/h-no-cache req opts)\n                       (f/xhr-cors req opts)\n                       (f/status-200 req opts))\n                     false)\n                 ;; register the new channel\n                 (if-not (session/session? session-id)\n                   (let [s (session/create-streaming-session\n                             session-id (fn [m] (str m \&quot;\\n\&quot;))\n                             :response-limit response-limit\n                             :heatbeat-delay heatbeat-delay\n                             :disconnect-delay disconnect-delay\n                             :sockjs-handler sockjs-handler)]\n                     (initialize-session s channel sockjs-handler))\n                   (session/register-new-channel! session-id channel)))}))&quot; &quot;(defn eventsource\n    \&quot;the eventsource handler\&quot;\n    [req session-id {:keys [sockjs-handler heatbeat-delay disconnect-delay\n                            response-limit] :as opts}]\n    (async/with-channel req channel\n      (if-not (session/session? session-id)\n        (let [s (session/create-streaming-session\n                 session-id (fn [m] (str \&quot;data: \&quot; m \&quot;\\r\\n\\r\\n\&quot;))\n                 :response-limit response-limit\n                 :heatbeat-delay heatbeat-delay\n                 :disconnect-delay disconnect-delay\n                 :sockjs-handler sockjs-handler)]\n          ;; TODO: only send for new session or everytime the client connects???\n          (async/send! channel\n                        (-&gt;&gt; {:status 200\n                              :headers {\&quot;Content-Type\&quot;\n                                        \&quot;text/event-stream; charset=UTF-8\&quot;}\n                              :body \&quot;\\r\\n\&quot;}\n                             (f/h-sid req opts)\n                             (f/h-no-cache req opts))\n                        false)\n          (initialize-session s channel sockjs-handler))\n        (session/register-new-channel! session-id channel))))&quot; &quot;(defn xhr-streaming\n  \&quot;the xhr streaming request handler.\&quot;\n  [req session-id {:keys [sockjs-handler heatbeat-delay disconnect-delay\n                          response-limit] :as opts}]\n  (async/as-channel req\n    {:on-close (fn [channel] \n                   (session/update-session! session-id #(session/close! % 1002 \&quot;Connection interrupted\&quot;)))}\n    {:on-open (fn [channel\n                    (async/send! channel) \n                    (-&gt;&gt; {:status 200}\n                       :headers {\&quot;Content-Type\&quot;\n                                 \&quot;application/javascript; charset=UTF-8\&quot;}\n                       :body (str (apply str (repeat 2048 \&quot;h\&quot;)) \&quot;\\n\&quot;)\n                      (f/h-sid req opts)\n                      (f/h-no-cache req opts)\n                      (f/xhr-cors req opts)\n                      (f/status-200 req opts))\n                    false]\n                ;; register the new channel\n                (if-not (session/session? session-id)\n                  (let [s (session/create-streaming-session\n                            session-id (fn [m] (str m \&quot;\\n\&quot;))\n                            :response-limit response-limit\n                            :heatbeat-delay heatbeat-delay\n                            :disconnect-delay disconnect-delay\n                            :sockjs-handler sockjs-handler)]\n                    (initialize-session s channel sockjs-handler))\n                  (session/register-new-channel! session-id channel)))}))&quot; &quot;(defn xhr-streaming\n  \&quot;the xhr streaming request handler.\&quot;\n  [req session-id {:keys [sockjs-handler heatbeat-delay disconnect-delay\n                          response-limit] :as opts}]\n  (async/as-channel req\n    {:on-close (fn [channel] \n                   (session/update-session! session-id #(session/close! % 1002 \&quot;Connection interrupted\&quot;)))}\n    {:on-open (fn [channel\n                    (async/send! channel \n                       (-&gt;&gt; {:status 200}\n                          :headers {\&quot;Content-Type\&quot;\n                                    \&quot;application/javascript; charset=UTF-8\&quot;}\n                          :body (str (apply str (repeat 2048 \&quot;h\&quot;)) \&quot;\\n\&quot;)\n                         (f/h-sid req opts)\n                         (f/h-no-cache req opts)\n                         (f/xhr-cors req opts)\n                         (f/status-200 req opts))\n                       false)])}))&quot; &quot;(defn eventsource\n  \&quot;the eventsource handler\&quot;\n  [req session-id {:keys [sockjs-handler heatbeat-delay disconnect-delay\n                          response-limit] :as opts}]\n  (async/as-channel req\n    {:on-open (fn [channel]\n                (if-not (session/session? session-id)\n                  (let [s (session/create-streaming-session\n                           session-id (fn [m] (str \&quot;data: \&quot; m \&quot;\\r\\n\\r\\n\&quot;))\n                           :response-limit response-limit\n                           :heatbeat-delay heatbeat-delay\n                           :disconnect-delay disconnect-delay\n                           :sockjs-handler sockjs-handler)]\n                    ;; TODO: only send for new session or everytime the client connects???\n                    (async/send! channel\n                                  (-&gt;&gt; {:status 200\n                                        :headers {\&quot;Content-Type\&quot;\n                                                  \&quot;text/event-stream; charset=UTF-8\&quot;}\n                                        :body \&quot;\\r\\n\&quot;}\n                                       (f/h-sid req opts)\n                                       (f/h-no-cache req opts))\n                                  false)\n                    (initialize-session s channel sockjs-handler))\n                  (session/register-new-channel! session-id channel)))}))&quot; &quot;(defn- polling\n  \&quot;Handle a polling request. (see `xhr-polling` and `jsonp`)\&quot;\n  [req session-id sockjs-handler fmt disconnect-delay &amp; [preclude]]\n  (async/as-channel req \n    {:on-close (fn [status]                \n                   (session/unregister-channel! session-id)\n                   (when (= status :client-close)\n                     (session/update-session! session-id\n                                              #(session/close! % 1002 \&quot;Connection interrupted\&quot;))))}\n    {:on-open (fn [channel]\n                (when preclude\n                  (async/send! channel preclude false))\n                ;; register the new channel\n                (if-not (session/session? session-id)\n                  (let [s (session/create-polling-session\n                           session-id fmt\n                           :sockjs-handler sockjs-handler\n                           :disconnect-delay disconnect-delay)]\n                    (initialize-session s channel sockjs-handler))\n                  (session/register-new-channel! session-id channel)))}))&quot; &quot;(defn xhr-polling\n  \&quot;handles the xhr polling request\&quot;\n  [req session-id {:keys [sockjs-handler disconnect-delay] :as opts}]\n  (polling req session-id sockjs-handler (fn [m] (str m \&quot;\\n\&quot;))\n           disconnect-delay\n           (-&gt;&gt; {:headers {\&quot;Content-Type\&quot;\n                           \&quot;application/javascript; charset=UTF-8\&quot;}}\n                (f/h-sid req opts)\n                (f/h-no-cache req opts)\n                (f/xhr-cors req opts)\n                (f/status-200 req opts))))&quot; &quot;(defn jsonp\n  \&quot;handles the jsonp polling request\&quot;\n  [req session-id {:keys [sockjs-handler disconnect-delay] :as opts}]\n  (let [cb (or (-&gt; req :params :c)\n               (-&gt; req :params :callback))]\n    ;; first we need to check if we have a callback parameter\n    (cond\n     (empty? cb)\n     (error-500 \&quot;\\\&quot;callback\\\&quot; parameter required\&quot;)\n     \n     (not (nil? (re-matches #\&quot;[^a-zA-Z0-9-_.]\&quot; cb)))\n     (error-500 \&quot;invalid \\\&quot;callback\\\&quot; parameter\&quot;)\n\n     ;; we have a valid callback parameter. Handle the polling request.\n     :else\n     (polling req session-id sockjs-handler\n              (fn [m] (str cb \&quot;(\&quot; (json/generate-string m) \&quot;);\\r\\n\&quot;))\n              disconnect-delay\n              (-&gt;&gt; {:headers {\&quot;Content-Type\&quot;\n                              \&quot;application/javascript; charset=UTF-8\&quot;}}\n                   (f/h-sid req opts)\n                   (f/h-no-cache req opts))))))&quot; &quot;(def iframe-template-html\n  \&quot;&lt;!doctype html&gt;\n&lt;html&gt;&lt;head&gt;\n  &lt;meta http-equiv=\\\&quot;X-UA-Compatible\\\&quot; content=\\\&quot;IE=edge\\\&quot; /&gt;\n  &lt;meta http-equiv=\\\&quot;Content-Type\\\&quot; content=\\\&quot;text/html; charset=UTF-8\\\&quot; /&gt;\n&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Don't panic!&lt;/h2&gt;\n  &lt;script&gt;\n    document.domain = document.domain;\n    var c = parent.{{ callback }};\n    c.start();\n    function p(d) {c.message(d);};\n    window.onload = function() {c.stop();};\n  &lt;/script&gt;\n\&quot;)&quot; &quot;(def iframe-template\n  (str iframe-template-html\n       (apply str (repeat (+ (- 1024 (.length iframe-template-html)) 14) \&quot; \&quot;))\n       \&quot;\\r\\n\\r\\n\&quot;))&quot; &quot;(defn htmlfile\n  \&quot;handle the html file request\&quot;\n  [req session-id {:keys [sockjs-handler heatbeat-delay disconnect-delay\n                          response-limit] :as opts}]\n  (let [cb (or (-&gt; req :params :c)\n               (-&gt; req :params :callback))]\n    ;; only handle the polling request if we have a valid callback\n    (cond\n     (empty? cb)\n     (error-500 \&quot;\\\&quot;callback\\\&quot; parameter required\&quot;)\n     \n     (not (nil? (re-matches #\&quot;[^a-zA-Z0-9-_.]\&quot; cb)))\n     (error-500 \&quot;invalid \\\&quot;callback\\\&quot; parameter\&quot;)\n\n     :else\n     (let [fmt-f #(str \&quot;&lt;script&gt;\\np(\&quot;\n                       (json/generate-string %)\n                       \&quot;);\\n&lt;/script&gt;\\r\\n\&quot;)]\n       (async/with-channel req channel\n         ;; send a preclude before every request\n         (async/send! channel\n                       (-&gt;&gt; {:status 200\n                             :headers {\&quot;Content-Type\&quot;\n                                       \&quot;text/html; charset=UTF-8\&quot;}\n                             :body (.replace iframe-template\n                                             \&quot;{{ callback }}\&quot; cb)}\n                            (f/h-sid req opts)\n                            (f/h-no-cache req opts)\n                            (f/status-200 req opts))\n                       false)\n         (if-not (session/session? session-id)\n           (let [s (session/create-streaming-session\n                    session-id fmt-f\n                    :sockjs-handler sockjs-handler\n                    :heatbeat-delay heatbeat-delay\n                    :disconnect-delay disconnect-delay\n                    :response-limit response-limit)]\n             (initialize-session s channel sockjs-handler))\n           (session/register-new-channel! session-id channel)))))))&quot; &quot;(defn htmlfile\n  \&quot;handle the html file request\&quot;\n  [req session-id {:keys [sockjs-handler heatbeat-delay disconnect-delay\n                          response-limit] :as opts}]\n  (let [cb (or (-&gt; req :params :c)\n               (-&gt; req :params :callback))]\n    ;; only handle the polling request if we have a valid callback\n    (cond\n     (empty? cb)\n     (error-500 \&quot;\\\&quot;callback\\\&quot; parameter required\&quot;)\n     \n     (not (nil? (re-matches #\&quot;[^a-zA-Z0-9-_.]\&quot; cb)))\n     (error-500 \&quot;invalid \\\&quot;callback\\\&quot; parameter\&quot;)\n\n     :else\n     (let [fmt-f #(str \&quot;&lt;script&gt;\\np(\&quot;\n                       (json/generate-string %)\n                       \&quot;);\\n&lt;/script&gt;\\r\\n\&quot;)]\n       (async/as-channel req \n         {:on-open (fn [channel]               \n         ;; send a preclude before every request\n                     (async/send! channel\n                                   (-&gt;&gt; {:status 200\n                                         :headers {\&quot;Content-Type\&quot;\n                                                   \&quot;text/html; charset=UTF-8\&quot;}\n                                         :body (.replace iframe-template\n                                                         \&quot;{{ callback }}\&quot; cb)}\n                                        (f/h-sid req opts)\n                                        (f/h-no-cache req opts)\n                                        (f/status-200 req opts))\n                                   false)\n                     (if-not (session/session? session-id)\n                       (let [s (session/create-streaming-session\n                                session-id fmt-f\n                                :sockjs-handler sockjs-handler\n                                :heatbeat-delay heatbeat-delay\n                                :disconnect-delay disconnect-delay\n                                :response-limit response-limit)]\n                         (initialize-session s channel sockjs-handler))\n                       (session/register-new-channel! session-id channel)))})))))&quot; &quot;(defn common-send [req session-id sockjs-handler read-body-f success-msg]\n  (try\n    (let [body (read-body-f req)]\n      (if (= (.length body) 0)\n        (error-500 \&quot;Payload expected.\&quot;)\n        (let [messages (json/parse-string body)\n              s (session/-&gt;session session-id)]\n          (if (and (not (nil? s))\n                   (= :open (:ready-state s)))\n            (do\n              ;; call on message handler\n              (session/update-session!\n               session-id\n               (fn [s]\n                 (reduce #(session/on-message sockjs-handler %1 %2)\n                         s messages)))\n              ;; return success message\n              success-msg)\n            ;; if session is closed return a 404\n            response-404))))\n    (catch com.fasterxml.jackson.core.JsonParseException e\n      (error-500 \&quot;Broken JSON encoding.\&quot;))\n    (catch Exception e\n      (.printStackTrace e)\n      (error-500 \&quot;unkown error\&quot;))))&quot; &quot;(defn xhr-send [req session-id {:keys [sockjs-handler] :as opts}]\n  (common-send\n   req session-id sockjs-handler\n   (fn [r] (let [b (:body req)]\n             (if (nil? b) \&quot;\&quot; (slurp b))))\n   (-&gt;&gt; {:status 204\n         :headers {\&quot;Content-Type\&quot; \&quot;text/plain; charset=UTF-8\&quot;}\n         :body \&quot;\&quot;}\n        (f/h-sid req opts)\n        (f/h-no-cache req opts)\n        (f/xhr-cors req opts))))&quot; &quot;(defn jsonp-send [req session-id {:keys [sockjs-handler] :as opts}]\n  (common-send\n   req session-id sockjs-handler\n   (fn [r] (let [b (or (-&gt; req :params :d) (:body req))]\n             (cond\n              (nil? b) \&quot;\&quot;\n              (string? b) b\n              :else (slurp b))))\n   (-&gt;&gt; {:status 200\n         :headers {\&quot;Content-Type\&quot; \&quot;text/plain; charset=UTF-8\&quot;}\n         :body \&quot;ok\&quot;}\n        (f/h-sid req opts)\n        (f/h-no-cache req opts))))&quot; &quot;(defn xhr-streaming\n  \&quot;the xhr streaming request handler.\&quot;\n  [req session-id {:keys [sockjs-handler heatbeat-delay disconnect-delay\n                          response-limit] :as opts}]\n  (async/as-channel req\n    {:on-open (fn [channel]\n                  (async/send! channel\n                     (-&gt;&gt; {:status 200}\n                        :headers {\&quot;Content-Type\&quot;\n                                  \&quot;application/javascript; charset=UTF-8\&quot;}\n                        :body (str (apply str (repeat 2048 \&quot;h\&quot;)) \&quot;\\n\&quot;)\n                       (f/h-sid req opts)\n                       (f/h-no-cache req opts)\n                       (f/xhr-cors req opts)\n                       (f/status-200 req opts))\n                     false)\n                  ;; register the new channel\n                  (if-not (session/session? session-id)\n                    (let [s (session/create-streaming-session\n                              session-id (fn [m] (str m \&quot;\\n\&quot;))\n                              :response-limit response-limit\n                              :heatbeat-delay heatbeat-delay\n                              :disconnect-delay disconnect-delay\n                              :sockjs-handler sockjs-handler)]\n                      (initialize-session s channel sockjs-handler))\n                    (session/register-new-channel! session-id channel)))}\n    {:on-close (fn [channel]\n                 (session/update-session! session-id #(session/close! % 1002 \&quot;Connection interrupted\&quot;)))}))&quot; &quot;(defroutes all-routes\n  (GET \&quot;/\&quot; [] \&quot;hello world\&quot;)\n  ;(sockjs-handler \&quot;/echo\&quot; (-&gt;EchoConnection) {:response-limit 4096})\n  ;(sockjs-handler \&quot;/close\&quot; (-&gt;CloseConnection) {:response-limit 4096})\n  (sockjs-handler \&quot;/disabled_websocket_echo\&quot; (-&gt;EchoConnection)\n                  {:response-limit 4096\n                   :websocket false}))&quot; &quot;(+ 1 1)&quot; &quot;(defroutes all-routes\n  (GET \&quot;/\&quot; [] \&quot;hello world\&quot;)\n  (sockjs-handler \&quot;/echo\&quot; (-&gt;EchoConnection) {:response-limit 4096}\n  ;(sockjs-handler \&quot;/close\&quot; (-&gt;CloseConnection) {:response-limit 4096})\n ; (sockjs-handler \&quot;/disabled_websocket_echo\&quot; (-&gt;EchoConnection)\n                  {:response-limit 4096\n                   :websocket false}))&quot; &quot;(-main)&quot; &quot;(run-python-protocol-test)&quot;], :remote []}}</component>
</project>